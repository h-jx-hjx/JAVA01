**数字相关**
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210521160306492.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p3MjFzanJj,size_16,color_FFFFFF,t_70)
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210521160403327.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p3MjFzanJj,size_16,color_FFFFFF,t_70)
double和float都不能表示精确的数字
例如
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210521160613108.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p3MjFzanJj,size_16,color_FFFFFF,t_70)

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210521160750575.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p3MjFzanJj,size_16,color_FFFFFF,t_70)
**JAVA**自带方法
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210521160827792.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p3MjFzanJj,size_16,color_FFFFFF,t_70)

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210521160905570.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p3MjFzanJj,size_16,color_FFFFFF,t_70)
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210521161108659.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p3MjFzanJj,size_16,color_FFFFFF,t_70)

**随机数，我觉得挺重要的**![在这里插入图片描述](https://img-blog.csdnimg.cn/20210521161340186.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p3MjFzanJj,size_16,color_FFFFFF,t_70)
**各种基本运算**
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210521161502691.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p3MjFzanJj,size_16,color_FFFFFF,t_70)
**字符串相关类**
String和Strinbuffer，stringbuild
![在这里插入图片描述](https://img-blog.csdnimg.cn/2021052116180257.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p3MjFzanJj,size_16,color_FFFFFF,t_70)
**由于 StringBuilder 相较于 StringBuffer 有速度优势，所以多数情况下建议使用 StringBuilder 类。然而在应用程序要求线程安全的情况下，则必须使用 StringBuffer 类。**
**（1）如果要操作少量的数据用 String；

（2）多线程操作字符串缓冲区下操作大量数据 StringBuffer；

（3）单线程操作字符串缓冲区下操作大量数据 StringBuilder。**
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210521162534176.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p3MjFzanJj,size_16,color_FFFFFF,t_70)
下面是对字符串的一些基本操作
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210521162705285.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p3MjFzanJj,size_16,color_FFFFFF,t_70)
![在这里插入图片描述](https://img-blog.csdnimg.cn/2021052116325293.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p3MjFzanJj,size_16,color_FFFFFF,t_70)

**时间相关**
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210521164531308.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p3MjFzanJj,size_16,color_FFFFFF,t_70)
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210521164551861.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p3MjFzanJj,size_16,color_FFFFFF,t_70)
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210521165041876.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p3MjFzanJj,size_16,color_FFFFFF,t_70)
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210521165056374.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p3MjFzanJj,size_16,color_FFFFFF,t_70)
年月日
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210521165331708.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p3MjFzanJj,size_16,color_FFFFFF,t_70)
**格式化相关**
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210521165541572.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p3MjFzanJj,size_16,color_FFFFFF,t_70)
有好多东西，要背下来
**作业**

输入一个字符串，请判断是否满足身份证基本要求，并返回具体的生日yyyy-mm-dd。如果输入数据有误，请输出0000-00-00。基本要求是：a)必须是18位；b) 前面位数必须是数字，最后一位可以是数字或小写字母；c) 日期是存在的；d)最后一位校验码检查。



校验码规则如下：



1、将前面的身份证号码17位数分别乘以不同的系数。从第一位到第十七位的系数分别为：7－9－10－5－8－4－2－1－6－3－7－9－10－5－8－4－2。



2、将这17位数字和系数相乘的结果相加。



3、用加出来和除以11，看余数是多少？



4、余数只可能有0－1－2－3－4－5－6－7－8－9－10这11个数字。其分别对应的最后一位身份证的号码为1－0－X－9－8－7－6－5－4－3－2。



5、通过上面得知如果余数是3，就会在身份证的第18位数字上出现的是9。如果对应的数字是10，身份证的最后一位号码就是罗马数字x。



输入格式:

一个身份证号，18位



输出格式：

yyyy-mm-dd



输入样例：

53010219200508011x



输出样例：

1920-05-08

```java




import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.Date;
import java.text.DateFormat;
import java.text.SimpleDateFormat;
public class ID
{
    public static void main(String[] args) throws IOException
    {
        BufferedReader buffer = new BufferedReader(new InputStreamReader(System.in));
        System.out.println("身份证号");
        String identity = buffer.readLine();

        if(identity.length()!=18)
        {
            System.out.println("0000-00-00");

        }
        else
        {
            int i,n=0;
            for( i=0;i<17;i++)
            {
                if(identity.charAt(i)>='0'&&identity.charAt(i)<='9')
                {
                    n++;
                }
                else
                    break;
            }

            if(n<=16||!(identity.charAt(17)>='0'&&identity.charAt(17)<='9'||identity.charAt(17)>='a'&&identity.charAt(17)<='z'))
                System.out.println("0000-00-00");
            else
            {
                int year,month,day;
                //装箱
                year=Integer.valueOf(identity.substring(6, 10));
                month=Integer.valueOf(identity.substring(10, 12));
                day=Integer.valueOf(identity.substring(12, 14));

                String strDate = identity.substring(6, 14);
                // 准备第一个模板，从字符串中提取出日期数字
                String pat1 = "yyyyMMdd" ;
                // 准备第二个模板，将提取后的日期数字变为指定的格式
                String pat2 = "yyyy-MM-dd" ;
                SimpleDateFormat sdf1 = new SimpleDateFormat(pat1) ;        // 实例化模板对象
                SimpleDateFormat sdf2 = new SimpleDateFormat(pat2) ;        // 实例化模板对象
                Date d = null ;
                try{
                    d = sdf1.parse(strDate) ;   // 将给定的字符串中的日期提取出来
                }catch(Exception e){            // 如果提供的字符串格式有错误，则进行异常处理
                    e.printStackTrace() ;       // 打印异常信息
                }
                String r=sdf1.format(d);
                if(r.equals(strDate))
                {
                    //校验算法
                    int j,m,sum=0,mod;
                    int [] k= {7,9,10,5,8,4,2,1,6,3,7,9,10,5,8,4,2};
                    for(j=0;j<17;j++)
                    {
                        m=Integer.valueOf(identity.substring(j, j+1));
                        sum+=k[j]*m;
                    }

                    mod=sum%11;
                    String mods="10x98765432";
                    if(identity.charAt(17)==mods.charAt(mod))
                        System.out.println(sdf2.format(d)) ;// 将日期变为新的格式
                    else

                        System.out.println("0000-00-00");
                }
                else
                    System.out.println("0000-00-00");

            }
        }
    }
}


```